# 2.3 웹 MVC와 JDBC의 결합

JDBC를 이용해서 DAO를 구성했다. 이후에는 1장에서 만든 서비스와 컨트롤러 객체를 연동해서 최종적으로 실행 가능한 웹 애플리케이션을
만드려고 함

## ModelMapper 라이브러리
- TodoDTO 생성
  ```java
  @Builder
  @Data
  @NoArgsConstructor
  @AllArgsConstructor
  public class TodoDTO {
    private Long tno;
    private String title;
    private LocalDate dueDate;
    private boolean finished;
  }
  ```
  - TodoVO와 완전히 같은 구조를 가지고 있지만 어노테이션 차이가 있다.
  - TodoDTO의 경우 @Data를 이용하는데 @Data는 getter/setter/toString/equals/hashCode 등을 모두 컴파일할 때 생성해준다.
  - VO의 경우 getter만 이용해서 읽기 전용으로 구성하는 것과 차이가 있음 (가능하다면 VO는 주로 읽기 위주의 작업을 위해서 사용)
  > DTO와 VO를 둘 다 만들어야 하는가에 대한 논쟁은 존재하지만 필자는 DTO와 VO를 구분해서 만드는 방식이 더 나은 방법이라고 생각함. 
  > 우선은 나중에 사용하게 될 JPA에서는 필수적이기 때문에 필요하고, 스프링에서도 DTO는 검증이나 변환에서 전혀 다른 어노테이션들이 필요하기 때문
- 여기서 가장 번거로운 것은 DTO <-> VO 의 변환이다.
- 이를 ModelMapper 라이브러리를 이용해 처리한다.
  1. dependencies 추가,
  ```groovy
  dependencies {
  
  ...

  // https://mvnrepository.com/artifact/org.modelmapper/modelmapper
  implementation group: 'org.modelmapper', name: 'modelmapper', version: '2.1.1'
  }
  ```
  2. 현재 예제의 경우 DTO는 getter/setter 모두를 사용하지만 VO의 경우는 getter만을 사용하기 때문에 ModelMapper 설정을 변경해서 사용할것, 
  일단 이를 위해 TodoVO에 생성자 관련 어노테이션 추가
  ```java
  @Getter
  @Builder
  @ToString
  @NoArgsConstructor
  @AllArgsConstructor
  public class TodoVO {
  private Long tno;
  private String title;
  private LocalDate dueDate;
  private boolean finished;
  }
  ```
  > @NoArgsConstructor로 파라미터가 없는 생성자, @AllArgsConstructor로 모든 필드값이 필요한 생성자를 만들어낸다.
  3. 프로젝트에 util 패키지를 추가한 후 ModelMapper의 설정을 변경하고 쉽게 사용할 수 있는 MapperUtil을 enum으로 생성
  ```java
  import org.modelmapper.ModelMapper;
  import org.modelmapper.config.Configuration;
  import org.modelmapper.convention.MatchingStrategies;
  
  public enum MapperUtil {
    INSTANCE;
    
    private ModelMapper modelMapper;
    
    MapperUtil(){
      this.modelMapper = new ModelMapper();
      this.modelMapper.getConfiguration()
              .setFieldMatchingEnabled(true)
              .setFieldAccessLevel(Configuration.AccessLevel.PRIVATE)
              .setMatchingStrategy(MatchingStrategies.STRICT);
    }
    
    public ModelMapper get(){
      return modelMapper;
    }
    
  }
  ```
  > getConfiguration()를 이용해 private로 선언된 필드도 접근 가능하도록 설정을 변경하고 get()을 이용해 ModelMapper를 사용할 수 있도록 구성


## TodoService와 ModelMapper 테스트
- DTO와 VO를 둘 다 이용해야 하는 TodoService를 구성하고 ModelMapper의 동작을 확인하도록 하기
- service패키지 생성 후 TodoService를 enum으로 선언
  ```java
  public enum TodoService {
    INSTANCE;
  
    private TodoDAO dao;
    private ModelMapper modelMapper;
  
    TodoService() {
      dao = new TodoDAO();
      modelMapper = MapperUtil.INSTANCE.get();
    }
  
    public void register(TodoDTO todoDTO)throws Exception{
      TodoVO todoVO = modelMapper.map(todoDTO, TodoVO.class);
      System.out.println("todoVO: " + todoVO);
      dao.insert(todoVO);     //int를 반환하므로 이를 이용해서 예외처리도 가능
    }
  
  }
  ```
  > TodoDTO객체를 파라미터로 받아서 TodoVO로 변환 후 TodoDAO로 데이터베이스에 삽입하는 register()생성, 
  > todoVO를 System.out.println()을 이용하여 출력하는 것은 Log4j2로 조금 뒤에서 대체될 예정
- Test Code로 확인
  - test/java/org.zerock에 service패키지 생성 후 TodoServiceTests생성
  - TodoService의 register을 테스트 할 수 있는 코드 생성
  ```java
  public class TodoServiceTests {
    private TodoService todoService;
  
    @BeforeEach
    public void ready(){
      todoService = TodoService.INSTANCE;
    }
  
    @Test
    public void testRegister()throws Exception{
      TodoDTO todoDTO = TodoDTO.builder()
              .title("JDBC Test Title")
              .dueDate(LocalDate.now())
              .build();
      todoService.register(todoDTO);
    }
  
  }
  ```
  > 테스트 코드 실행 후, TodoVO의 내용이 잘 출력되는지와 데이터베이스에 삽입이 잘 되었는지 확인하면 된다.

## Log4j2와 @Log4j2

### 사용 이유
- 프로젝트를 개발하다보면 많은 System.out.println()을 이용
- 문제는 개발이 끝나고 난 후 대부분의 System.out.println()는 필요가 없어서 해당 부분을 삭제하거나 주석 처리 해야함 -> 매우 번거롭다.
- `로그 기능은 이러한 문제를 해결하기 위한 기능이고 예제에서는 Log4j2를 이용할 것` (2021년 말에 Log4j 관련 보안 위험성 문제의 패치 버전인 2.17.0 이상 버전을 사용)

### 특징
- Log4j2는 `level`이라는 설정이 있어서 개발할 때, 실제 운영 시에 필요한 로그를 쉽게 구분 가능
- Lombok의 경우 @Log4j2라는 어노테이션을 이용해서 간단히 소스 코드 내에 로그를 적용할 수 있다.
- Log4j2에서 가장 핵심적인 개념은 로그의 `level`과 어펜더`Appender`이다.
- `Appender`
  - Appender : 로그를 어떤 방식으로 기록할 것인지를 의미, 콘솔창에 출력할 것인지 파일로 출력할 것인지 등을 결정
  - System.out.println()대신 콘솔(console) 어펜더(Appender)라는 것을 지정해서 사용
- `Level`
  - 로그의 레벨은 로그의 `중요도` 개념
  - System.out.println()으로 작성하면 모든 내용이 출력되지만, 로그의 레벨을 지정하면 해당 레벨 이상의 로그만 출력
  - 그래서, 개발할 때는 로그의 레벨을 많이 낮게 설정해서 개발하고 운영할 때는 중요한 로그들만 기록하게 설정
  - 로그 레벨은 다음과 같다.
  ```
  TRACE -> DEBUG -> INFO -> WARN -> ERROR -> FATAL
  ``` 
  > 오른쪽으로 갈 수록 레벨이 높은 것이고, Level을 지정하면 상위 Level의 로그만 출력된다. 예를 들어 레벨이 ERROR인 경우 FATAL, ERROR 레벨의 로그만 출력
  - 일반적으로 개발할 때는 Info 이하의 레벨을 이용, 운영할 때는 Error나 Warn 이상을 사용

### 사용하기
1. build.gradle에 의존성 추가
  ```groovy
  dependencies {
    compileOnly('javax.servlet:javax.servlet-api:4.0.1')
  
    ...
  
    //log4j2
    implementation group: 'org.apache.logging.log4j', name: 'log4j-core', version: '2.17.2'
    implementation group: 'org.apache.logging.log4j', name: 'log4j-api', version: '2.17.2'
  
    implementation group: 'org.apache.logging.log4j', name: 'log4j-slf4j-impl', version: '2.17.2'
  }
  ```
2. log4j2.xml 설정파일 생성
   - Log4j2 라이브러리 설정은 log4j2.xml이라는 파일을 이용해 설정한다.
   - 앞서 언급했던 Appender나 Log Level을 설정하는 파일
   - 파일을 통해 설정하기 때문에 나중에 파일 내용만 변경하면 코드 수정 없이 바로 변경된 레벨 적용 가능
   - 프로젝트의 src/main/resources에 생성
    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <Configuration status="WARN">
        <Appenders>
            <Console name="Console" target="SYSTEM_OUT">
                <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
            </Console>
        </Appenders>
        <Loggers>
            <Root level="info">
                <AppenderRef ref="Console"/>
            </Root>
        </Loggers>
    </Configuration>
    ```
   > 좀 더 자세한 설정은 https://logging.apache.org/log4j/2.x/manual/configuration.html 를 참고할 것
3. Lombok의 @Log4j2 어노테이션 적용하기 - TodoService
   - TodoService코드에 @Log4j2어노테이션을 추가하고 System.out.println()대신 log.info()와 같은 코드로 변경
    ```java
    @Log4j2
    public enum TodoService {
      INSTANCE;
    
      private TodoDAO dao;
      private ModelMapper modelMapper;
    
      TodoService() {
        dao = new TodoDAO();
        modelMapper = MapperUtil.INSTANCE.get();
      }
    
      public void register(TodoDTO todoDTO)throws Exception{
        TodoVO todoVO = modelMapper.map(todoDTO, TodoVO.class);
    
    //    System.out.println("todoVO: " + todoVO);
        log.info(todoVO);
    
        dao.insert(todoVO);     //int를 반환하므로 이를 이용해서 예외처리도 가능
      }
    
    }
    ```
   - TodoServiceTests를 이용해서 testRegister()를 실행하면 다음과 같이 변경된 로그가 출력
    ```
    05:33:56.002 [Test worker] INFO  org.zerock.jdbcex.service.TodoService - TodoVO(tno=null, title=JDBC Test Title, dueDate=2024-02-24, finished=false)
    05:33:56.014 [Test worker] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Starting...
    05:33:58.355 [Test worker] INFO  com.zaxxer.hikari.pool.HikariPool - HikariPool-1 - Added connection org.mariadb.jdbc.Connection@588ffeb
    05:33:58.357 [Test worker] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Start completed.
    ```
    > 결과에서 눈여겨 봐야할 부분은 HikariCP의 로그 역시 다르게 출력된다는 점이다. 이것은 HikariCP가 내부적으로 slf4j 라이브러리를 이용하고 있는데, build.gradle의 log4j-slf4j-impl 라이브러리가 Log4j2를 이용할 수 있도록 설정되기 때문
4. Lombok의 @Log4j2 어노테이션 적용하기 - 테스트 환경에서 사용
  - 테스트 환경에서 @Log4j2 기능을 활용하기 위해서는 테스트 환경에서도 어노테이션을 처리하는 다음과 같은 설정이 추가되어 있어야 한다.
  ```groovy
  dependencies {
    testCompileOnly 'org.projectlombok:lombok:1.18.30'
    testAnnotationProcessor 'org.projectlombok:lombok:1.18.30'
  }
  ```
  - 설정을 반영하고 테스트 코드를 수정
  ```java
  @Log4j2
  public class TodoServiceTests {
    private TodoService todoService;
  
    @BeforeEach
    public void ready(){
      todoService = TodoService.INSTANCE;
    }
  
    @Test
    public void testRegister()throws Exception{
      TodoDTO todoDTO = TodoDTO.builder()
              .title("JDBC Test Title")
              .dueDate(LocalDate.now())
              .build();
  
      log.info("------------------------------------------"); //테스트 코드의 Log4j2설정 확인
      log.info(todoDTO);
  
      todoService.register(todoDTO);
    }
    
  }
  ```
  > 변경된 코드는 @Log4j2를 이용하도록 수정하고, log.info()를 이용해 로그를 출력한다.
  - 실행 결과 확인
  ```
  05:39:12.157 [Test worker] INFO  org.zerock.service.TodoServiceTests - ------------------------------------------
  05:39:12.159 [Test worker] INFO  org.zerock.service.TodoServiceTests - TodoDTO(tno=null, title=JDBC Test Title, dueDate=2024-02-24, finished=false)
  05:39:12.171 [Test worker] INFO  org.zerock.jdbcex.service.TodoService - TodoVO(tno=null, title=JDBC Test Title, dueDate=2024-02-24, finished=false)
  05:39:12.182 [Test worker] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Starting...
  05:39:12.496 [Test worker] INFO  com.zaxxer.hikari.pool.HikariPool - HikariPool-1 - Added connection org.mariadb.jdbc.Connection@67ec8477
  05:39:12.497 [Test worker] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Start completed.
  ```


## 컨트롤러와 서비스 객체의 연동

